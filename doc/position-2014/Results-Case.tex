\subsection{Case study: Interoperable Integration of Tools and Middleware}
\label{case}
When it comes to an RM run-time system, it is 
not only performance and scalability,
but also easy integration and interoperability, that are critical.
In particular, next-generation systems impose greater productivity
challenges, and \flux\ must mitigate this by supporting a rich 
productivity software ecosystem. 
Here, we present our experiences of porting our development
environment software as a case study
to show \flux's ability to facilitate building this ecosystem. 

As part of our design strategy, we decided to 
co-design the porting of several run-time tools, middleware 
and their infrastructure along with \flux's run-time system,
including the Stack Trace Analysis Tool (STAT)~\cite{STAT},
a highly scalable lightweight debugging tool;
the Scalable Parallel Input Network for Dynamic Loading
Environment ({\sc Spindle})~\cite{SPINDLE}),
a scalable program loading middleware system;
and LaunchMON~\cite{launchmon}, a daemon launching infrastructure.

We chose them because they represent a class of run-time
software which places similar demands on the RM,
for example, scalably launching and bootstrapping
distributed processes to establish a scalable 
communication fabric.
They also exhibit a common need to co-locate daemons with, 
find information about, and synchronize their states with 
the target application processes.

Perhaps more importantly, we decided to use these programs
in our co-design because they suffer interoperability issues on 
today's RMs~\cite{Jette02slurm,ALPS,BGQRes,Castain05theopen}.
Users cannot easily use both STAT
and {\sc Spindle} simultaneously because they contend for
the MPIR process acquisition interface~\cite{MPIRInterface}.
While de factor standard, this interface is designed 
to be used by a single tool at a time. 
A more flexible and sharable mechanism must be provided by \flux.

Our general approach was to support a wide range of run-time software programs 
at the same level as we support other parallel programming 
models such as MPI. For this, we heavily relied on lightweight 
job (LWJ). We treated 
distributed processes of these run-time programs
as LWJs and used \flux's 
generic run-time services to launch/bootstrap them and 
relate them to the target application.% processes.

Our first step was to rework LaunchMON
to directly use \flux's run-time mechanisms instead 
of the MPIR interface. Specifically, its engine
and its back-end API run-time
was modified to use the \flux\ KVS
to exchange connection information about 
distributed processes of its client tools in a similar way that MPI run-time 
uses it. 

Once LaunchMON was ported to \flux, porting
STAT and {\sc Spindle} was
straightforward since both rely on LaunchMON---it took less than one week each.
Under the new scheme, STAT's daemons 
and {\sc Spindle} server processes were simply LWJs 
that use our scalable services to act on the target processes, 
another LWJ. STAT uses these services to debug the 
target; {\sc Spindle} to connect to the network clients sitting on the target.

Further, by avoiding the MPIR interface, 
this approach made these programs interoperable.
Users can now scalably start-up a massive application 
that dynamically loads hundreds of shared libraries 
using {\sc Spindle}.
If this job suffers a bug, they can also apply
STAT to debug it transparently.
This is new and shows that \flux\ can address extreme-scale 
code-development challenges by enabling tool interoperability.
