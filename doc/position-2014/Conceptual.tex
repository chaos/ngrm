\section{Conceptual design of \flux}
\label{models}

In this paper we present \flux, a novel open-source RJMS framework that
targets the paradigm discussed above. In the following
we will describe its
%
%Flux is the open-source RJMS framework we are actively
%investigating to embody the new paradigm while
%addressing the multitude of challenges described above.
%This section describes some of its 
fundamental design
concepts.

\vspace{1ex}
\noindent{\em Unified Job Model: } In the traditional paradigm, 
a job is simply defined to be a resource allocation. 
\flux, however, abstracts this notion to an independent 
RJMS instance that can either be used to run a single job
or that can 
%. This treats any \flux job has 
%an independent resource and allows it to 
run its own job management services,
which then can recursively accept and schedule jobs and provide its own 
services to them. 
In the following we will refer to this simply as a \flux job or just job.
To provide the necessary flexibility,
%The 
each RJMS instance 
%must be delegated
%the main responsibility of managing the resources allocated
%to its job. But it 
allows specialized service
plug-ins to be instantiated so that the resources managed by the job
can be used differently than other resources (in terms of security, scheduling policy, or resource constraints).
This model forms 
the foundation for hierarchical,
multilevel resource management and job scheduling
with resource subset specialization.

\vspace{1ex}
\noindent{\em Job Hierarchy Model:} To scale the new paradigm 
to the entire HPC center, we must avoid a centralized approach. 
Instead, \flux exploits the hierarchical resource management 
and job scheduling discussed above and organizes itself in a tree-based hierarchy of \flux jobs. 
Several guiding principles throughout the job hierarchy strike 
a balance between the management responsibility 
of a parent job and delegation and empowerment of a child job:

\begin{itemize}
\item{Parent bounding rule: the parent job grants 
and confines the resource allocation of all of its children.}

\item{Child empowerment rule: within the bounds set 
by the parent, the child job is delegated the ownership 
of the allocation and becomes solely responsible 
for most efficient uses of the resources.}

\item{Parental consent rule: the child job asks 
its parent when it wants to grow or shrink the resource 
allocation, and it is up to the parent to grant the request.}
\end{itemize}

This model has many advantages for scalability of both
resource management and job scheduling. 
The independent and specialized \flux service instance
of a job becomes only responsible for managing its direct
children jobs, which would be only a small fraction of
the total number of jobs at the center. 
As sibling jobs run simultaneously, their independent
\flux instances will perform concurrent management services.

For example, for job scheduling, this model enables \flux
to exploit scheduling parallelism~\cite{Omega,Mesos}.
A parent scheduler schedules at coarse granularity 
over a large collection of resources and leases different resource subsets 
to its children schedulers. 
At the same time, this will enable Flux to specialize the scheduling behaviors 
on subsets of resources without having to introduce a
complex global scheduling policy into the centralized, monolithic scheduler. 

%Trying to cut - seems repetitive
%This model enforces the first principle 
%of the new paradigm: imposing highly complex resource bounds 
%to provide high operational efficiency 
%at any level across the entire center, while enabling 
%most efficient execution and scheduling of the workloads 
%within these bounds. 
%Further, this addresses 
%many of the identified challenges in Section~\ref{label:paradigm} 
%including the {\em multidimensional scale} and 
%{\em diverse/dynamic workload} challenges. 

%\vspace{1ex}
\noindent{\em Generalized Resource Model:} In the traditional 
paradigm, compute resources are modeled primarily 
as a collection of compute nodes. But this is a simplistic perspective 
ill-suited for the new paradigm. Today's applications 
are diverse with disparate limiting performance factors 
beyond floating point computation. 
Further, computing centers are increasingly concerned 
about managing new resource types such as power 
and shared persistent storage. \flux therefore introduces a generalized resource
model that it is extensible and covers any kind of resource and its relationships. This enables scheduling
decisions based on many types of resources.

%addresses this need by providing an extensible
%and flexible representation for resources
%and their relationships.

%\vspace{1ex}
\noindent{\em Multilevel Resource Elasticity Model:} As our 
applications and their programming models are becoming 
increasingly dynamic, the new paradigm demands 
an elasticity model where an existing resource allocation 
can grow and shrink, depending on the current needs 
of applications and/or the HPC center. 
\flux supports the elasticity model within our job hierarchy 
framework above: a child job sends a grow or shrink request 
to its parent, which can be aggregated up the job hierarchy 
until all requisite constraints are known for this request. 
Also, combining this with the generalized resource model, 
the elasticity can be expressed for any resource including 
power. 

%Our elasticity model addresses 
%the {\em dynamic workload} challenge.

%\vspace{1ex}
\noindent{\em Common Scalable Communication Infrastructure Model:} 
To maintain scalability both within and across jobs, \flux 
%Our scalability strategy with respect to a large number 
%of compute nodes is to 
provides a common scalable communication 
framework within each job. When a job is created, a secure, scalable 
overlay network with common communication service is established 
across its allocated nodes. Except for the root-level job, 
the existing communication session of the parent job assists 
the child job with rapid creation of its own session. 

A communication session is only aware of its parent 
and child and passes the limited set of control information 
through its communication channel. Thus, this model 
enables highly scalable communication within a job, while 
limiting communications between jobs, addressing 
both the multidimensional scale as well as security issues.
Further, this per-job backbone communication network 
supports well-known bootstrap interfaces 
for distributed programs including many MPI implementations 
as well as run-time tools. This provides tightly integrated support
for the development and use of scalable run-time tools.
%, which 
%can have a large impact on user productivity.
