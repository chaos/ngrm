The goal of this report is to convey the core principles behind the
Communications Message Broker / Key Value Store infrastructure.
Without this explanation, new developers are faced with a thicket of
code and need to sift through that code and email messages to begin to
perceive the underlying structure.  This report identifies the
paradigms of communication offered by the cmb, the associated
utilities that implement those paradigms, and the underlying plumbing
that can safely be ignored.  The discussion starts off at a general
level and visits each core concept in greater detail.  It omits
implementation details that are irrelevant to developing comms modules
that use the cmb.

cmb is built on top of ZeroMQ.  For an introduction to ZeroMQ, see
http://zguide.zeromq.org/

cmb follows these standard messaging patterns supplied by ZeroMQ:
	publish/subscribe
	dealer/router

For more details, see
http://zguide.zeromq.org/page:all#Messaging-Patterns.

The cmb daemon (cmbd.c) is imbued with a full set of communication
patterns plus the ability to load comms modules.  There is one cmbd
per rank.  While there is nominally one rank per compute node, this is
not a requirement.  That one cmbd loads from one to many comms modules
that will define its behavior.  These run in the address space of the
cmbd and communicate with the cmb using ZeroMQ over shared memory.
Comms modules generally register a service that can receive requests.

There are two mechanisms for cmbd to cmbd communication: requests (and
their optional responses) and events.  Further details can be found in
the zmq-broker/README.  All the messaging facilities for the cmb are
defined in the flux.h file.

Requests (and responses) follow the dealer/router pattern (a more
versatile model than ZeroMQ's request/reply pattern).  It is used by
one cmbd to send a message to another cmbd and receive a response.
Requests are usually sent blindly upstream and are either picked up by
a comms module implementing a matching service, or get a negative
response if they reach the root unmatched.  The router is "upstream"
and allows multiple downstream peers to connect; the dealer is
"downstream" and connects to exactly one upstream URI.  We send
requests upstream, and replies downstream.  Replies are optional.

Events are implemented with ZeroMQ's publish/subscribe pattern.

One cmbd subscriber registers a callback with the flux reactor for
requests, replies, and events.  The cmbd publisher sends a message to
the specific RPC and the cmbd subscriber's callback will be invoked.

One of the key components to the cmb is the Key Value Store.  The kvs
is implemented as a comms module and, as such, provides its services
to all comms modules.  Its main user functions are get, put, and
watch.  Watch is a service to alert subscribing modules that a
directory or value has changed.  Comms modules request this service by
registering a callback for the specific change of interest (via
kvs_watch_*()).  All of the kvs operations are defined in kvs.h.  They
work with flux handles and the flux reactor.

The standard operation for a comms module is to do the following:

	Register the message handlers for the requests and events it
	wants to receive.

	Register specific callbacks for changes to specific kvs
	directory entries.

	Enter a loop waiting for the requested messages by calling
	flux_reactor_start()

The modules are dlopen'ed and have to provide a well-known entry point
by defining:

const struct plugin_ops ops = {
    .main = my_main,
};

Each module is spawned in its own cmbd thread.  The thread's control
is passed to the module's main function.  main's arguments include an
initialized flux handle (fronting shared memory sockets to the cmbd),
and a means for picking up module specific arguments.

Services

Here are some of the services available in the cmb:

apisrv - bridge unix domain API socket and ZeroMQ message broker

barriersrv - implements barriers of arbitrary membership

echosrv - echoes a message back to the sender

eventsrv - provides the infrastructure for delivering events

hbsrv - issues a heartbeat event to services that register for them

livesrv - provides a service that responds to "are you alive?" requests

logsrv - logs messages to a file at the requested log level

mechosrv - copy input arguments to output arguments and respond to RPC

monsrv - provides a reduction infrastructure to aggregate statistics of interest

ranksrv - relays messages to parent or child cmbd's.

Security

CURVE security is mandatory.  Run ./flux-keygen to generate personal
CURVE keys.  The cmbd will read these on startup and implement privacy
and integrity on all messages sent over the wire.

Odds and Ends

While the cmb codebase offers the building blocks for Flux comms
modules, it also provides stand-alone client implementations that
allows one to exercise the cmb comms modules' functionality directly.
These manual clients to the cmb servers appear in the form of the
various flux-* commands.

The entire cmb infrastructure has a Lua interface for developers who
prefer to write comms modules in the Lua language.

There are a variety of tests located in the test directory that
exercise and demonstrate the kvs functionality.

./flux snoop is useful for watching traffic flow through the cmb.

Also useful for tracing messages sent/received by utilities is the
flux --trace-apisock option, for example:

./flux --trace-apisock kvsdir -Rv

Here's a way to display the entire contents of the kvs:
./flux kvsdir -Rv
